var documenterSearchIndex = {"docs":
[{"location":"api/core/#Core-Functions","page":"Core Functions","title":"Core Functions","text":"","category":"section"},{"location":"api/core/","page":"Core Functions","title":"Core Functions","text":"For more detailed documentation see the R package documentation (PDF). Note that function signatures and exposed functions are equivalent to the R version.","category":"page"},{"location":"api/core/#Bayesian-Methods","page":"Core Functions","title":"Bayesian Methods","text":"","category":"section"},{"location":"api/core/","page":"Core Functions","title":"Core Functions","text":"BayesianFM\nBayesianSDF\ncontinuous_ss_sdf\ncontinuous_ss_sdf_v2\ndirac_ss_sdf_pvalue","category":"page"},{"location":"api/core/#BayesianFactorZoo.BayesianFM","page":"Core Functions","title":"BayesianFactorZoo.BayesianFM","text":"BayesianFM(f::Matrix{Float64}, R::Matrix{Float64}, sim_length::Int)\n\nBayesian Fama-MacBeth regression. Similar to BayesianSDF but estimates factors' risk premia rather than risk prices.\n\nArguments\n\nf: Matrix of factors with dimension t times k, where k is the number of factors and t is the number of periods\nR: Matrix of test assets with dimension t times N, where t is the number of periods and N is the number of test assets\nsim_length: Length of MCMCs\n\nDetails\n\nUnlike BayesianSDF, we use factor loadings, beta_f, instead of covariance exposures, C_f, in the Fama-MacBeth regression. After obtaining posterior draws of mu_Y and Sigma_Y (see BayesianSDF), we calculate:\n\nReturns\n\nReturns a BayesianFMOutput struct containing:\n\nlambda_ols_path::Matrix{Float64}: Matrix of size simlength × (k+1) containing OLS risk premia estimates. First column is ``\\lambdac`` for constant term, next k columns are factor risk premia.\nlambda_gls_path::Matrix{Float64}: Matrix of size sim_length × (k+1) containing GLS risk premia estimates.\nR2_ols_path::Vector{Float64}: Vector of length sim_length containing OLS R^2 draws.\nR2_gls_path::Vector{Float64}: Vector of length sim_length containing GLS R^2 draws.\nMetadata fields accessible via dot notation:\nn_factors::Int: Number of factors (k)\nn_assets::Int: Number of test assets (N)\nn_observations::Int: Number of time periods (t)\nsim_length::Int: Number of MCMC iterations performed\n\nReferences\n\nBryzgalova S, Huang J, Julliard C (2023). \"Bayesian solutions for the factor zoo: We just ran two quadrillion models.\" Journal of Finance, 78(1), 487–557.\n\nExamples\n\n# Run Bayesian FM regression with 10,000 iterations  \nresults = BayesianFM(f, R, 10_000)\n\n# Access results\nols_risk_premia = mean(results.lambda_ols_path, dims=1)  # Mean OLS risk premia\ngls_r2 = mean(results.R2_gls_path)  # Mean GLS R²\n\n\n\n\n\n","category":"function"},{"location":"api/core/#BayesianFactorZoo.BayesianSDF","page":"Core Functions","title":"BayesianFactorZoo.BayesianSDF","text":"BayesianSDF(f::Matrix{Float64}, R::Matrix{Float64}, sim_length::Int=10000; \n           intercept::Bool=true, type::String=\"OLS\", prior::String=\"Flat\",\n           psi0::Float64=5.0, d::Float64=0.5)\n\nBayesian estimation of Linear SDF (B-SDF).\n\nArguments\n\nf: Matrix of factors with dimension t times k\nR: Matrix of test assets with dimension t times N\nsim_length: Length of MCMCs\nintercept: Include intercept if true, default=true\ntype: \"OLS\" or \"GLS\", default=\"OLS\"\nprior: \"Flat\" or \"Normal\", default=\"Flat\"\npsi0: Hyperparameter for normal prior, default=5\nd: Hyperparameter for normal prior, default=0.5\n\nReturns\n\nReturns a BayesianSDFOutput struct containing:\n\nlambda_path::Matrix{Float64}: Matrix of size simlength × (k+1) if intercept=true, or simlength × k if false. Contains posterior draws of risk prices.\nR2_path::Vector{Float64}: Vector of length sim_length containing R^2 draws.\nMetadata fields accessible via dot notation:\nn_factors::Int: Number of factors (k)\nn_assets::Int: Number of test assets (N)\nn_observations::Int: Number of time periods (t)\nsim_length::Int: Number of MCMC iterations performed\nprior::String: Prior specification used (\"Flat\" or \"Normal\")\nestimation_type::String: Estimation type used (\"OLS\" or \"GLS\")\n\nNotes\n\nInput matrices f and R must have the same number of rows (time periods)\nNumber of test assets (N) must be larger than number of factors (k) when including intercept\nNumber of test assets (N) must be >= number of factors (k) when excluding intercept\nThe function performs no pre-standardization of inputs\nRisk prices are estimated in the units of the input data (typically monthly returns)\n\nReferences\n\nBryzgalova S, Huang J, Julliard C (2023). \"Bayesian solutions for the factor zoo: We just ran two quadrillion models.\" Journal of Finance, 78(1), 487–557.\n\nExamples\n\n# Basic usage with default settings\nresults = BayesianSDF(f, R)\n\n# Use GLS with normal prior\nresults_gls = BayesianSDF(f, R, 10_000; \n                        type=\"GLS\", \n                        prior=\"Normal\",\n                        psi0=5.0,\n                        d=0.5)\n\n# Access results\nrisk_prices = mean(results.lambda_path, dims=1)\nr2_values = mean(results.R2_path)\n\n\n\n\n\n","category":"function"},{"location":"api/core/#BayesianFactorZoo.continuous_ss_sdf","page":"Core Functions","title":"BayesianFactorZoo.continuous_ss_sdf","text":"continuous_ss_sdf(f::Matrix{Float64}, R::Matrix{Float64}, sim_length::Int;\n                psi0::Float64=1.0, r::Float64=0.001,\n                aw::Float64=1.0, bw::Float64=1.0,\n                type::String=\"OLS\", intercept::Bool=true)\n\nSDF model selection using continuous spike-and-slab prior.\n\nArguments\n\nf: Matrix of factors with dimension t times k\nR: Matrix of test assets with dimension t times N\nsim_length: Length of MCMCs\npsi0: Hyperparameter in prior distribution of risk prices\nr: Hyperparameter for spike component (ll 1)\naw,bw: Beta prior parameters for factor inclusion probability\ntype: \"OLS\" or \"GLS\"\nintercept: Include intercept if true\n\nReturns\n\nReturns a ContinuousSSSDFOutput struct containing:\n\ngammapath::Matrix{Float64}: Matrix of size simlength × k containing posterior draws of factor inclusion indicators.\nlambdapath::Matrix{Float64}: Matrix of size simlength × (k+1) if intercept=true, or sim_length × k if false. Contains posterior draws of risk prices.\nsdfpath::Matrix{Float64}: Matrix of size simlength × t containing posterior draws of the SDF.\nbma_sdf::Vector{Float64}: Vector of length t containing the Bayesian Model Averaged SDF.\nMetadata fields accessible via dot notation:\nn_factors::Int: Number of factors (k)\nn_assets::Int: Number of test assets (N)\nn_observations::Int: Number of time periods (t)\nsim_length::Int: Number of MCMC iterations performed\n\nNotes\n\nInput matrices f and R must have the same number of rows (time periods)\nThe method automatically handles both traded and non-traded factors\nPrior parameters aw, bw control beliefs about model sparsity (default values favor no sparsity)\nParameter psi0 maps into prior beliefs about achievable Sharpe ratios\nThe spike component r should be close to zero to effectively shrink irrelevant factors\nThe resulting SDF is normalized to have mean 1\n\nReferences\n\nBryzgalova S, Huang J, Julliard C (2023). \"Bayesian solutions for the factor zoo: We just ran two quadrillion models.\" Journal of Finance, 78(1), 487–557.\n\nExamples\n\n# Basic usage with default settings\nresults = continuous_ss_sdf(f, R, 10_000)\n\n# Use GLS with modified priors for more aggressive selection\nresults_gls = continuous_ss_sdf(f, R, 10_000;\n                             type=\"GLS\",\n                             psi0=0.5,     # Tighter prior\n                             aw=1.0,       \n                             bw=9.0)       # Prior favoring sparsity\n\n# Access results\ninclusion_probs = mean(results.gamma_path, dims=1)  # Factor inclusion probabilities\nrisk_prices = mean(results.lambda_path, dims=1)     # Posterior mean risk prices\nsdf = results.bma_sdf                              # Model averaged SDF\n\n\n\n\n\n","category":"function"},{"location":"api/core/#BayesianFactorZoo.continuous_ss_sdf_v2","page":"Core Functions","title":"BayesianFactorZoo.continuous_ss_sdf_v2","text":"continuous_ss_sdf_v2(f1::Matrix{Float64}, f2::Matrix{Float64}, R::Matrix{Float64},\n                   sim_length::Int; psi0::Float64=1.0, r::Float64=0.001,\n                   aw::Float64=1.0, bw::Float64=1.0,\n                   type::String=\"OLS\", intercept::Bool=true)\n\nSDF model selection with continuous spike-and-slab prior, treating tradable factors as test assets.\n\nArguments\n\nf1: Matrix of nontradable factors with dimension t times k_1\nf2: Matrix of tradable factors with dimension t times k_2\nR: Matrix of test assets with dimension t times N (should NOT contain f2)\nsim_length: Length of MCMCs\npsi0,r,aw,bw,type,intercept: Same as continuoussssdf\n\nDetails\n\nSame prior structure and posterior distributions as continuoussssdf, but:\n\nTreats tradable factors f2 as test assets\nTotal dimension of test assets becomes N + k_2\nFactor loadings computed on combined test asset set\n\nReturns\n\nReturns a ContinuousSSSDFOutput struct containing:\n\ngamma_path::Matrix{Float64}: Matrix of size simlength × k containing posterior draws of factor inclusion indicators, where ``k = k1 + k_2`` (total number of factors).\nlambda_path::Matrix{Float64}: Matrix of size simlength × (k+1) if intercept=true, or simlength × k if false. Contains posterior draws of risk prices.\nsdf_path::Matrix{Float64}: Matrix of size sim_length × t containing posterior draws of the SDF.\nbma_sdf::Vector{Float64}: Vector of length t containing the Bayesian Model Averaged SDF.\nMetadata fields accessible via dot notation:\nn_factors::Int: Number of factors (k_1 + k_2)\nn_assets::Int: Number of test assets (N)\nn_observations::Int: Number of time periods (t)\nsim_length::Int: Number of MCMC iterations performed\n\nNotes\n\nInput matrices f1, f2, and R must have the same number of rows (time periods)\nTest assets R should not include the tradable factors f2\nThe factor selection combines both sparsity and density aspects through Bayesian Model Averaging\nPrior parameters aw, bw control beliefs about model sparsity\nParameter psi0 maps into prior beliefs about achievable Sharpe ratios\nThe spike component r should be close to zero to effectively shrink irrelevant factors\n\nReferences\n\nBryzgalova S, Huang J, Julliard C (2023). \"Bayesian solutions for the factor zoo: We just ran two quadrillion models.\" Journal of Finance, 78(1), 487–557.\n\nExamples\n\n# Basic usage with default settings\nresults = continuous_ss_sdf_v2(f1, f2, R, 10_000)\n\n# Use GLS with custom priors\nresults_gls = continuous_ss_sdf_v2(f1, f2, R, 10_000;\n                                type=\"GLS\",\n                                psi0=2.0,\n                                aw=2.0, \n                                bw=2.0)\n\n# Access results\ninclusion_probs = mean(results.gamma_path, dims=1)  # Factor inclusion probabilities\nrisk_prices = mean(results.lambda_path, dims=1)     # Risk price estimates\navg_sdf = results.bma_sdf                          # Model averaged SDF\n\n\n\n\n\n","category":"function"},{"location":"api/core/#BayesianFactorZoo.dirac_ss_sdf_pvalue","page":"Core Functions","title":"BayesianFactorZoo.dirac_ss_sdf_pvalue","text":"dirac_ss_sdf_pvalue(f::Matrix{Float64}, R::Matrix{Float64}, sim_length::Int,\n                  lambda0::Vector{Float64}; psi0::Float64=1.0,\n                  max_k::Union{Int,Nothing}=nothing)\n\nHypothesis testing for risk prices using Dirac spike-and-slab prior.\n\nArguments\n\nf: Matrix of factors with dimension t times k\nR: Matrix of test assets with dimension t times N\nsim_length: Length of MCMCs\nlambda0: k times 1 vector of null hypothesis values\npsi0: Hyperparameter in prior distribution\nmax_k: Maximum number of factors in models (optional)\n\nReturns\n\nReturns a DiracSSSDFOutput struct containing:\n\ngamma_path::Matrix{Float64}: Matrix of size sim_length × k containing posterior draws of factor inclusion indicators.\nlambda_path::Matrix{Float64}: Matrix of size sim_length × (k+1) containing posterior draws of risk prices.\nmodel_probs::Matrix{Float64}: Matrix of size M × (k+1) where M is the number of possible models. First k columns are model indices (0/1), last column contains model probabilities.\nMetadata fields accessible via dot notation:\nn_factors::Int: Number of factors (k)\nn_assets::Int: Number of test assets (N)\nn_observations::Int: Number of time periods (t)\nsim_length::Int: Number of MCMC iterations performed\n\nNotes\n\nInput matrices f and R must have the same number of rows (time periods)\nThe method is particularly useful for testing specific hypotheses about risk prices\nSetting max_k allows for focused testing of sparse models\nThe Dirac spike provides a more stringent test than the continuous spike-and-slab\nBayesian p-values can be constructed by integrating 1-p(γ|data)\nModel probabilities are properly normalized across the considered model space\n\nReferences\n\nBryzgalova S, Huang J, Julliard C (2023). \"Bayesian solutions for the factor zoo: We just ran two quadrillion models.\" Journal of Finance, 78(1), 487–557.\n\nExamples\n\n# Test if all risk prices are zero\nlambda0 = zeros(size(f, 2))\nresults = dirac_ss_sdf_pvalue(f, R, 10_000, lambda0)\n\n# Test specific values with max 3 factors\nlambda0_alt = [0.5, 0.3, -0.2, 0.1]\nresults_sparse = dirac_ss_sdf_pvalue(f, R, 10_000, lambda0_alt; max_k=3)\n\n# Access results\ninclusion_probs = mean(results.gamma_path, dims=1)  # Factor inclusion probabilities\nrisk_prices = mean(results.lambda_path, dims=1)     # Posterior mean risk prices\ntop_models = results.model_probs[sortperm(results.model_probs[:,end], rev=true)[1:10], :] # Top 10 models\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Classical-Methods","page":"Core Functions","title":"Classical Methods","text":"","category":"section"},{"location":"api/core/","page":"Core Functions","title":"Core Functions","text":"SDF_gmm\nTwoPassRegression","category":"page"},{"location":"api/core/#BayesianFactorZoo.SDF_gmm","page":"Core Functions","title":"BayesianFactorZoo.SDF_gmm","text":"SDF_gmm(R::Matrix{Float64}, f::Matrix{Float64}, W::Matrix{Float64})\n\nGMM estimation of factor risk prices under linear SDF framework.\n\nArguments\n\nR: Matrix of test assets with dimension t times N\nf: Matrix of factors with dimension t times k\nW: Weighting matrix for GMM estimation, dimension (N+k) times (N+k)\n\nReturns\n\nReturns a SDFGMMOutput struct containing:\n\nlambda_gmm::Vector{Float64}: Vector of length k+1 containing risk price estimates (includes intercept).\nmu_f::Vector{Float64}: Vector of length k containing estimated factor means.\nAvar_hat::Matrix{Float64}: Matrix of size (2k+1) × (2k+1) containing asymptotic covariance matrix.\nR2_adj::Float64: Adjusted cross-sectional R^2.\nS_hat::Matrix{Float64}: Matrix of size (N+k) × (N+k) containing estimated spectral density matrix.\nMetadata fields accessible via dot notation:\nn_factors::Int: Number of factors (k)\nn_assets::Int: Number of test assets (N)\nn_observations::Int: Number of time periods (t)\n\nNotes\n\nInput matrices R and f must have the same number of rows (time periods)\nThe weighting matrix W should match dimensions (N+k) × (N+k)\nFor tradable factors, weighting matrix should impose self-pricing restrictions\nImplementation assumes no serial correlation in moment conditions\nR² is adjusted for degrees of freedom\nStandard errors are derived under the assumption of correct specification\n\nReferences\n\nBryzgalova S, Huang J, Julliard C (2023). \"Bayesian solutions for the factor zoo: We just ran two quadrillion models.\" Journal of Finance, 78(1), 487–557.\n\nHansen, Lars Peter (1982). \"Large Sample Properties of Generalized Method of Moments Estimators.\" Econometrica, 50(4), 1029-1054.\n\nExamples\n\n# Construct OLS weighting matrix\nW_ols = construct_weight_matrix(R, f, \"OLS\")\n\n# Perform OLS estimation\nresults_ols = SDF_gmm(R, f, W_ols)\n\n# Construct GLS weighting matrix\nW_gls = construct_weight_matrix(R, f, \"GLS\")\n\n# Perform GLS estimation\nresults_gls = SDF_gmm(R, f, W_gls)\n\n# Access results\nrisk_prices = results_ols.lambda_gmm[2:end]  # Factor risk prices (excluding intercept)\nstd_errors = sqrt.(diag(results_ols.Avar_hat)[2:end])  # Standard errors\nr_squared = results_ols.R2_adj  # Adjusted R²\n\nSee Also\n\nconstruct_weight_matrix: Function to construct appropriate OLS/GLS weighting matrices\nBayesianSDF: Bayesian alternative that is robust to weak factors\n\n\n\n\n\n","category":"function"},{"location":"api/core/#BayesianFactorZoo.TwoPassRegression","page":"Core Functions","title":"BayesianFactorZoo.TwoPassRegression","text":"TwoPassRegression(f::Matrix{Float64}, R::Matrix{Float64})\n\nClassical Fama-MacBeth two-pass regression.\n\nArguments\n\nf: Matrix of factors with dimension t times k\nR: Matrix of test assets with dimension t times N\n\nReturns\n\nReturns a TwoPassRegressionOutput struct containing:\n\nlambda::Vector{Float64}: Vector of length k+1 containing OLS risk premia estimates (includes intercept).\nlambda_gls::Vector{Float64}: Vector of length k+1 containing GLS risk premia estimates.\nt_stat::Vector{Float64}: Vector of length k+1 containing OLS t-statistics.\ntstatgls::Vector{Float64}: Vector of length k+1 containing GLS t-statistics.\nR2_adj::Float64: OLS adjusted R².\nR2adjGLS::Float64: GLS adjusted R².\nalpha::Vector{Float64}: Vector of length N containing OLS pricing errors.\nt_alpha::Vector{Float64}: Vector of length N containing t-statistics for OLS pricing errors.\nbeta::Matrix{Float64}: Matrix of size N × k containing factor loadings.\ncov_epsilon::Matrix{Float64}: Matrix of size N × N containing residual covariance.\ncov_lambda::Matrix{Float64}: Matrix of size (k+1) × (k+1) containing OLS covariance matrix of risk premia.\ncovlambdagls::Matrix{Float64}: Matrix of size (k+1) × (k+1) containing GLS covariance matrix of risk premia.\nR2_GLS::Float64: Unadjusted GLS R².\ncov_beta::Matrix{Float64}: Matrix of size (N(k+1)) × (N(k+1)) containing covariance matrix of beta estimates.\nMetadata fields accessible via dot notation:\nn_factors::Int: Number of factors (k)\nn_assets::Int: Number of test assets (N)\nn_observations::Int: Number of time periods (t)\n\nNotes\n\nInput matrices f and R must have the same number of rows (time periods)\nThe method is vulnerable to bias from weak and useless factors\nStandard errors account for the EIV problem but assume serial independence\nBoth OLS and GLS estimates are computed with appropriate standard errors\nR² values are adjusted for degrees of freedom\nIncludes corrections for using factors as test assets when applicable\n\nReferences\n\nFama, Eugene F., and James D. MacBeth, 1973, Risk, return, and equilibrium: Empirical tests, Journal of Political Economy 81, 607-636.\n\nShanken, Jay, 1992, On the estimation of beta-pricing models, Review of Financial Studies 5, 1-33.\n\nExamples\n\n# Perform two-pass regression\nresults = TwoPassRegression(f, R)\n\n# Access OLS results\nrisk_premia = results.lambda[2:end]  # Factor risk premia (excluding intercept)\nt_stats = results.t_stat[2:end]      # t-statistics\nr2_ols = results.R2_adj              # Adjusted R²\npricing_errors = results.alpha        # Pricing errors\n\n# Access GLS results\nrisk_premia_gls = results.lambda_gls[2:end]  \nt_stats_gls = results.t_stat_gls[2:end]\nr2_gls = results.R2_adj_GLS\n\n# First-pass results\nbetas = results.beta                  # Factor loadings\nstd_errors_beta = sqrt.(diag(results.cov_beta))  # Standard errors for betas\n\nSee Also\n\nBayesianFM: Bayesian version that is robust to weak factors\nSDF_gmm: GMM-based alternative estimation approach\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#Utility-Functions","page":"Utility Functions","title":"Utility Functions","text":"","category":"section"},{"location":"api/utils/","page":"Utility Functions","title":"Utility Functions","text":"construct_weight_matrix\npsi_to_priorSR","category":"page"},{"location":"api/utils/#BayesianFactorZoo.construct_weight_matrix","page":"Utility Functions","title":"BayesianFactorZoo.construct_weight_matrix","text":"construct_weight_matrix(R::Matrix{Float64}, f::Matrix{Float64}, \n                     type::String=\"OLS\", kappa::Float64=1e6)\n\nConstruct weighting matrix for GMM estimation of linear SDF models.\n\nArguments\n\nR: Matrix of test assets with dimension t times N\nf: Matrix of factors with dimension t times k\ntype: \"OLS\" or \"GLS\", default=\"OLS\"\nkappa: Large constant for factor moment conditions, default=1e6\n\nDetails\n\nConstructs a (N+k) times (N+k) block diagonal weighting matrix W:\n\nW = beginbmatrix W_R  0_Ntimes k  0_ktimes N  kappa I_k endbmatrix\n\nwhere:\n\nOLS (type=\"OLS\"):\n\nW_R = I_N\n\nGLS (type=\"GLS\"):\n\nW_R = Sigma_R^-1\n\nThe structure reflects GMM moment conditions:\n\nEg_t(lambda_clambda_fmu_f) = E(R_t - lambda_c1_N - R_t(f_t - mu_f)lambda_f) (f_t - mu_f) = 0_N 0_k\n\nReturns\n\nReturns a Matrix{Float64} of size (N+k) times (N+k) containing the weighting matrix W with structure:\n\nUpper-left block: Identity (OLS) or inverse return covariance (GLS)\nLower-right block: kappa I_k\nOff-diagonal blocks: Zero matrices\n\nNote: The returned matrix matches the dimension requirements of SDF_gmm function\n\nNotes\n\nInput matrices R and f must have the same number of rows (time periods)\nThe GLS version requires a well-conditioned return covariance matrix\nκ should be large enough to ensure accurate factor mean estimation\nOutput matches dimensions required by SDF_gmm function\nBlock structure is optimal under conditional homoskedasticity\n\nReferences\n\nBryzgalova S, Huang J, Julliard C (2023). \"Bayesian solutions for the factor zoo: We just ran two quadrillion models.\" Journal of Finance, 78(1), 487–557.\n\nHansen, Lars Peter (1982). \"Large Sample Properties of Generalized Method of Moments Estimators.\" Econometrica, 50(4), 1029-1054.\n\nExamples\n\n# Construct OLS weighting matrix\nW_ols = construct_weight_matrix(R, f, \"OLS\")\n\n# Construct GLS weighting matrix\nW_gls = construct_weight_matrix(R, f, \"GLS\")\n\n# Use custom kappa value\nW_custom = construct_weight_matrix(R, f, \"OLS\", 1e8)\n\n# Use in GMM estimation\nresults_ols = SDF_gmm(R, f, W_ols)\nresults_gls = SDF_gmm(R, f, W_gls)\n\nSee Also\n\nSDF_gmm: Main function using these weighting matrices\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#BayesianFactorZoo.psi_to_priorSR","page":"Utility Functions","title":"BayesianFactorZoo.psi_to_priorSR","text":"psi_to_priorSR(R::Matrix{Float64}, f::Matrix{Float64}; \n              psi0::Union{Nothing,Float64}=nothing,\n              priorSR::Union{Nothing,Float64}=nothing,\n              aw::Float64=1.0, bw::Float64=1.0)\n\nMap between prior tightness parameter psi and prior Sharpe ratio.\n\nArguments\n\nR: Matrix of test assets with dimension t times N\nf: Matrix of factors with dimension t times k\npsi0: Prior tightness parameter to convert to SR\npriorSR: Target SR to convert to psi0\naw,bw: Beta prior parameters\n\nReturns\n\nReturns a Float64 value either:\n\nThe implied prior Sharpe ratio if psi0 provided\nThe required psi0 value if priorSR provided\n\nNote: Returns error message string if neither or both arguments are provided\n\nNotes\n\nExactly one of psi0 or priorSR must be provided\nInput matrices R and f must have the same number of rows (time periods)\nThe mapping helps choose priors based on economic intuition about achievable Sharpe ratios\nDefault aw=bw=1 implies 50% prior probability of factor inclusion\nThe relationship is monotonic: higher ψ implies higher prior Sharpe ratio\nUseful for calibrating priors in continuoussssdf and continuoussssdf_v2\n\nReferences\n\nBryzgalova S, Huang J, Julliard C (2023). \"Bayesian solutions for the factor zoo: We just ran two quadrillion models.\" Journal of Finance, 78(1), 487–557.\n\nExamples\n\n# Load test data\n# Convert psi0 to implied prior Sharpe ratio\nimplied_sr = psi_to_priorSR(R, f; psi0=5.0)\nprintln(\"Psi0 = 5.0 implies prior SR = $implied_sr\")\n\n# Find psi0 needed for target Sharpe ratio\nrequired_psi = psi_to_priorSR(R, f; priorSR=0.5)\nprintln(\"For prior SR = 0.5, need psi0 = $required_psi\")\n\n# Use custom Beta prior parameters\npsi_sparse = psi_to_priorSR(R, f; \n                          priorSR=0.3,\n                          aw=1.0, \n                          bw=9.0)  # Prior favoring sparsity\n\n# Helper functions also available:\nusing BayesianFactorZoo: calculate_prior_SR, find_psi_for_target_SR\n\n# Get prior SR for a given psi\nsr = calculate_prior_SR(5.0, R, f)\n\n# Get psi for a target SR\npsi = find_psi_for_target_SR(0.5, R, f)\n\nSee Also\n\ncontinuous_ss_sdf: Main function using this prior calibration\ncontinuous_ss_sdf_v2: Version for tradable factors using this calibration\n\n\n\n\n\n","category":"function"},{"location":"#BayesianFactorZoo.jl","page":"Home","title":"BayesianFactorZoo.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BayesianFactorZoo.jl is a Julia port of the R package 'BayesianFactorZoo' (CRAN link) implementing the econometric methods from the paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bryzgalova, S., Huang, J., & Julliard, C. (2023). Bayesian solutions for the factor zoo: We just ran two quadrillion models. Journal of Finance, 78(1), 487–557. DOI: 10.1111/jofi.13197","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more detailed function documentations please see the documentation of the R package Link to PDF","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BayesianFactorZoo.jl provides a comprehensive framework for analyzing linear asset pricing models that is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simple and robust\nApplicable to high-dimensional problems\nCapable of handling both tradable and non-tradable factors\nValid under model misspecification\nRobust to weak factors","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a stand-alone model, the package delivers reliable price of risk estimates and detects weakly identified factors. For competing factors and models, it provides automatic model selection or Bayesian model averaging when no clear winner exists.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For now this is not in the general registry (I will register it at some point). In the meantime you can install it directly from my repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"http://github.com/eohne/BayesianFactorZoo.jl\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using BayesianFactorZoo\n\n# Example with simulated data\nt, k, N = 600, 3, 25  # time periods, factors, assets\nf = randn(t, k)       # factor returns\nR = randn(t, N)       # asset returns\n\n# Perform Bayesian Fama-MacBeth regression\nresults_fm = BayesianFM(f, R, 10_000)\n\n# Estimate SDF with normal prior\nresults_sdf = BayesianSDF(f, R; prior=\"Normal\")\n\n# Model selection with continuous spike-and-slab\nresults_ss = continuous_ss_sdf(f, R, 10_000)","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bayesian Fama-MacBeth regression (BayesianFM)\nBayesian SDF estimation (BayesianSDF)\nModel selection via spike-and-slab priors (continuous_ss_sdf, continuous_ss_sdf_v2)\nHypothesis testing (dirac_ss_sdf_pvalue)\nGMM estimation (SDF_gmm)\nClassical two-pass regression (TwoPassRegression)","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{bryzgalova2023bayesian,\n  title={Bayesian solutions for the factor zoo: We just ran two quadrillion models},\n  author={Bryzgalova, Svetlana and Huang, Jiantao and Julliard, Christian},\n  journal={The Journal of Finance},\n  volume={78},\n  number={1},\n  pages={487--557},\n  year={2023}\n}","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Basic-Usage","page":"Tutorial","title":"Basic Usage","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates how to use BayesianFactorZoo.jl for estimating and selecting asset pricing models.","category":"page"},{"location":"tutorial/#Data-Preparation","page":"Tutorial","title":"Data Preparation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, let's prepare some example data:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using BayesianFactorZoo\nusing Random\nRandom.seed!(1234)\n\n# Generate example data\nt, k, N = 600, 3, 25  # time periods, factors, assets\nf = randn(t, k)       # factor returns\nR = randn(t, N)       # asset returns","category":"page"},{"location":"tutorial/#Bayesian-Fama-MacBeth-Regression","page":"Tutorial","title":"Bayesian Fama-MacBeth Regression","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Run Bayesian FM with 10,000 iterations\nresults_fm = BayesianFM(f, R, 10_000)\n\n# Analyze results\nmean_risk_premia = mean(results_fm.lambda_ols_path, dims=1)\nmean_r2 = mean(results_fm.R2_ols_path)","category":"page"},{"location":"tutorial/#Bayesian-SDF-Estimation","page":"Tutorial","title":"Bayesian SDF Estimation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Estimate SDF with normal prior\nresults_sdf = BayesianSDF(f, R; \n                         prior=\"Normal\",\n                         psi0=5.0)\n\n# Analyze results\nmean_risk_prices = mean(results_sdf.lambda_path, dims=1)\nmean_r2 = mean(results_sdf.R2_path)","category":"page"},{"location":"tutorial/#Model-Selection","page":"Tutorial","title":"Model Selection","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Run continuous spike-and-slab selection\nresults_ss = continuous_ss_sdf(f, R, 10_000;\n                             psi0=1.0,\n                             aw=1.0,\n                             bw=1.0)\n\n# Analyze factor inclusion probabilities\ninclusion_probs = mean(results_ss.gamma_path, dims=1)\n\n# Get model averaged SDF\nbma_sdf = results_ss.bma_sdf","category":"page"},{"location":"tutorial/#Advanced-Topics","page":"Tutorial","title":"Advanced Topics","text":"","category":"section"},{"location":"tutorial/#Prior-Calibration","page":"Tutorial","title":"Prior Calibration","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The package provides tools for setting economically meaningful priors:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Convert between psi and Sharpe ratios\nimplied_sr = psi_to_priorSR(R, f; psi0=5.0)\nrequired_psi = psi_to_priorSR(R, f; priorSR=0.5)","category":"page"},{"location":"tutorial/#Hypothesis-Testing","page":"Tutorial","title":"Hypothesis Testing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Test specific hypotheses about risk prices:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Test if risk prices are zero\nlambda0 = zeros(k)\nresults_test = dirac_ss_sdf_pvalue(f, R, 10_000, lambda0)\n\n# Analyze posterior probabilities\np_values = 1 .- mean(results_test.gamma_path, dims=1)","category":"page"},{"location":"tutorial/#Handling-Tradable-Factors","page":"Tutorial","title":"Handling Tradable Factors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When some factors are tradable, use the v2 version:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"k1, k2 = 2, 1  # 2 non-tradable, 1 tradable factor\nf1 = f[:, 1:k1]\nf2 = f[:, k1+1:end]\n\nresults_v2 = continuous_ss_sdf_v2(f1, f2, R, 10_000)","category":"page"}]
}
